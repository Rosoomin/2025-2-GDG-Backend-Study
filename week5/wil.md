# 객체 지향 프로그래밍(OOP)
- 컴퓨터 프로그램을 여러 독립적인 부품들의 조합, 즉 객체들의 상호작용으로 파악하고자하는 컴퓨터 프로그래밍의 패러다임
- 프로그램을 묶음 단위로 잘게 쪼개서 레고 블럭 조립하듯 전체 프로그램을 완성
- 객체 지향 프로그래밍은 유연하고 변경이 용이하기 때문에, 현업에서 대규모 소프트웨어 개발에 많이 사용

# 객체 지향의 네 가지 특징
- **추상화** : 객체의 공통적인 속성과 기능을 추출하여 정의하는 것, 복잡한 것을 단순화하는것. 프로그램의 구조를 명확하게 만듦
- **캡슐화** : 서로 연관있는 속성과 기능들을 하나의 캡슐로 만들어서 데이터를 외부로부터 보호하는것. 객체 내부 구현을 숨기고 외부에 필요한 정보만 공개함으로써 안전성과 보안, 유지 보수성을 높임.
- **상속** : 기존 클래스의 속성과 기능을 새로운 클래스가 물려받아 재사용 하는 것. 기존 코드를 효율적으로 재사용함으로써 코드의 중복을 줄임
- **다형성** : 어떤 객체의 속성이나 기능이 상황에 따라 여러 가지 형태를 가질 수 있는 성질, 즉 같은 메서드 호출이라도 객체의 종류에 따라서 다른 결과를 낼 수 있기때문에 유연하고 변경에 용이하고 또 확장가능한 코드 설계를 할 수 있음.

# 다형성
→ 어떤 역할에 대해 여러 가지 구현 방식이 존재할 수 있는 것!!
- 객체를 사용하는 쪽(클라이언트)은 대상의 역할만 알면됨. 구현 대상의 내부 구조, 어떻게 작동하는지는 알 필요가 없음. 그 결과 클라이언트는 구현의 변화로 부터 자유로워짐. 내부 구조가 변경되었다고해도 영향을 받지않음.
→ 다형성은 프로그램을 유연하고, 변경에 용이하게 해줌!!

## 다형성 적용하기
- 실제 Java 코드로 옮길때  
  **역할 → 인터페이스**  
  **구현 → 인터페이스를 구현한 클래스**

- 이때 인터페이스란 클래스가 구현해야 하는 메소드의 집합. 클래스의 설계도, 틀.

# SOLID : 좋은 객체 지향 설계를 위한 5가지 원칙
- SRP : 단일 책임 원칙
- OCP : 개방 - 폐쇄 원칙
- LSP : 리스코프 치환 원칙
- ISP : 인터페이스 분리 원칙
- DIP : 의존관계 역전 원칙

# SRP 단일 책임 원칙
- 하나의 클래스는 단 한개의 책임을 가져야 함
- 클래스를 변경하는 이유는 단 하나여야 함
- 하나의 클래스에 여러 기능(책임)이 있다면, 특정 기능이 변경될 떄 다른 기능에도 영향을 미치게 되어, 수정해야 할 코드가 많아지게 됨.
- 단일 책임 원칙의 목적은 프로그램의 유지보수성을 높이기 위한 것!

# OCP 개방 - 폐쇄 원칙
- 클래스는 확장에 열려있어야 하지만 수정에는 닫혀 있어야 한다는 원칙
- 확장이 열려있다는 것은 새로운 변경사항이 발생했을때 유연하게 애플리케이션의 기능을 확장할수 있어야하는것.
- 수정에 닫혀있다는 것은 새로운 변경사항이 발생했을때 기존 코드를 직접적으로 수정하는걸 제한하는 것
- 정리 : 기존 코드를 변경하지 않고 기능을 확장할 수 있도록 설계하는 것

# LSP 리스코프 치환 원칙
- 자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있어야한다는 것
- 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 프로그램이 기대하는 방식으로 동일하게 작동해야함  
예) 자동차 인테페이스에서 엑셀 메소드는 앞으로 간다라는 행동을 기대. 슈퍼카라는 자식 클래스를 만들때 엑셀 메소드를 뒤로간다라고 재정의를 했다면..  
→ 문법적으로는 문제 없지만 자동차를 운전하던 클라이언트는 슈퍼카를 타는 순간 사고가 나게됨
- 자식 클래스가 부모 클래스의 기능을 변경하면 안 됨
- 단순히 문법적인 상속이나 타입 호환성을 넘어서 행동적인 호환성까지 보장되어야 한다는 것

# ISP 인터페이스 분리 원칙
- 인터페이스를 각각 사용에 맞게 끔 잘게 분리해야함
- 클라이언트가 사용하지 않는 인터페이스에 의존하지 않도록 해야 함
- 클라이언트의 목적과 용도에 적합한 인터페이스 만을 제공
- 하나의 큰 인터페이스보다는 여러 개의 작은 인터페이스로 분리하는 것이 좋음  
→ 인터페이스가 명확해지고, 대체 가능성이 높아짐

# DIP 의존관계 역전 원칙
- 추상화에 의존해야지, 구체화에 의존하면 안 됨
- 구현 클래스에 의존하지말고, 인터페이스에 의존해야 함
- 의존 관계를 맺을 때 변화하기 쉬운 것보다는 변화하기 어려운 것에 의존
- 각 클래스 간의 결합도를 낮추기 위함

# 의존성
- 한 객체가 다른 객체의 기능을 필요로 해서 사용하는 관계

# 다형성만으로는 SOLID 원칙을 지킬 수 없다
- 스프링은 SOLID 원칙을 지키기 위해 의존성 주입을 지원함

# IoC : Inversion of Control 제어의 역전
- 객체 생성 및 관리에 대한 제어권을 개발자가 아닌 프레임워크가 대신 가져가는 것
- 스프링에서는 객체를 생성하고 관리하는 역할을 스프링 컨테이너가 함
- 스프링 컨테이너를 IoC라고도 함

# Spring container
- 스프링 빈 저장소
- Application Context

# Spring Bean & spring container
- 어플리케이션 전역에서 사용할 공용 객체
- 스프링 컨테이너가 관리하는 객체
- 스프링 컨테이너에 빈을 저장, 필요한 빈을 컨테이너에서 받아 사용

# 싱글톤 컨테이너
- 스프링 컨테이너는 객체를 딱 1개만 생성해서 필요할때마다 재사용할 수 있게 한다 → 싱글톤
- 매번 필요한 객체를 생성하는 대신, 생성해둔 객체를 사용하므로 메모리를 효율적으로 사용(매번 new를 사용 안해도 되기때문)

# Spring Bean 등록 방법
- 설정 파일 작성(수동 등록)
- 컴포넌트 스캔(자동 등록)

## 빈 수동 등록 - 설정 파일 작성
- @Configuration으로 설정 클래스를 생성
- 동록하고자 하는 객체를 반환하는 메소드에 @Bean 붙이기

# DI : Dependency Injection 의존성 주입
- IoC를 구현하는 방법
- 내가 의존하는 객체를 직접 생성하지 않고 밖에서 주입받는 것
- 스프링 컨테이너에 필요한 객체를 미리 생성해두고, 다른 객체에서 이 객체가 필요할 때 주입하는 것
- 인터페이스에만 의존하고, 구현 객체는 외부에서 주입 받음
- 애플리케이션 실행시점에 객체 간의 관계를 결정
- 느슨한 결합 → 한 클래스의 변경이 다른 클래스에 미치는 영향을 최소화
- 유연성, 유지보수성 높임

# 의존관계 자동 주입
- @Autowired
- 스프링 컨테이너에 등록된 빈 중에서 필요한 타입의 객체를 자동으로 찾아서 주입

# 의존성 주입 방법
1. 생성자 주입  
2. 수정자 주입(세터 주입)  
3. 필드 주입

## 생성자 주입
- 객체가 생성이 될때 필요한 의존성을 함께 주입하는 방식
- 스프링에서 가장 권장되는 주입 방법
- 생성자 호출시점에 단 한번만 주입이 일어남
- 필드를 final로 선언할 수 있어서 이후에는 의존성이 절대 변경되지 않게 가능
- 생성자에 필요한 의존성을 명시적으로 선언해야하기 때문에 스프링이 객체를 만들때 누락없이 반드시 필요한 의존성을 강제로 주입하도록함
- 생성자가 하나라면 @Autowired 생략 가능
- 롬복의 @RequiredArgsConstructor로 final이 붙은 필드의 생성자 자동 생성

## 수정자 주입
- 세터 메소드를 통해 의존관계를 주입하는 방법
- 객체를 먼저 생성한 다음 @Autowired가 붙은 세터 메소드를 호출해서 의존성을 나중에 주입
- 따라서 객체를 생성하는 시점에는 의존성이 필수가 아님
- 의존성을 선택적으로 주입가능
- 객체를 생성후에도 세터 메소드를 호출해서 의존 관계를 변경하거나 재설정 가능

## 필드 주입
- 생성자나 메소드 없이 필드에 @Autowired를 바로 붙이는 방식
- 테스트하기 힘들고, final 키워드를 사용할 수 없어 의존성이 바뀔수 있으며 의존 관계가 명확하게 드러나지 않음
- 권장되지 않는 방식

# 조회되는 빈이 2개 이상일때
- @Qualifier
- @Primary

## @Qualifier
- 빈에 추가 이름표 붙여주는 방식
- 여러개의 빈 중에서 특정 이름표를 가진 빈을 사용하겠다고 명시

## @Primary
- 우선순위를 정하는 방식
- @Primary가 붙은 빈을 우선적으로 선택
